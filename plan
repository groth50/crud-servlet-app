1. Пишем под апач томкат. Под джетти отдельно приложение чибрикова. Здесь будет только КРУД с секьюрити фильтрами и базой посгрес или MySql

Сделано:
1. GetIndexPage
2. SignIn
3. SignUp
4. LogOut
5. GetMainMenu
6. GetAdminMenu
7. SecurityFilter

8. AddUserServlet - Create part
9. DeleteUserServlet - Delete part
10. UpdateUserServlet - Update part

11. Раскидал на разные ветки работу с вебом и работу с базой
12. Сделать нормальный дизайн морды

Сделать:
0.

1. В какой пакет положить LongId<T>?
2. Возможно, ID сессии лучше сделать слабой ссылкой, чтобы они сами исчезали при чистке?

3. Использовать хэш вместо пассворда и солить хэш. Использовать токены(упрощённо).
4.
5. Подключить логгирование при деплое
6. завязать через DAO AccountService
7. Сделать конфиг DB через XML
8. Исключения в еррор пейдж https://www.tutorialspoint.com/jsp/jsp_exception_handling.htm
9. Веб морду сделать как здесь https://o7planning.org/ru/11071/create-a-simple-login-application-and-secure-pages-with-java-servlet-filter#a11092805
10. Парсер на правильность логина и пароля

Свистоперделки:
9. И для еще более удобного пользовательского интерфейса, если перехваченный запрос является GET,
 кешируйте его (или добавляйте его как скрытое поле на странице входа) и перенаправляйте на эту
 страницу после успешного входа в систему
 https://stackoverflow.com/questions/13274279/authentication-filter-and-servlet-for-login#13276996

Решения
1. Так как конфигурация не через майн, как в джетти, а через аннотации для апача, то пришлось accountService в Sign сервлетах инициализировать через инит.
Проблема в тестах. Поэтому в тестах использовал рефлекшн для изменения приватного поля в SignIn сервлете

2. Не отображались error message на странице JSP в JSTL, поправил web.xml - дескриптор развертки. Включил.
<web-app
        xmlns="http://java.sun.com/xml/ns/javaee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
        version="3.0">
</web-app>

 и в сами JSP странички включил
 <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
 <%@ page contentType="text/html;charset=UTF-8" language="java" %>

3. Не подтягивается css в jsp. Кстати, можно качнуить готовые css для оформления форм. Или использовать bootstrap.
   !!! Ебучий Томкат после любого запроса вызывл метод get у GetIndexPageServlet из-за того, что в url patterns был "/".
       Поэтому убрал / из  GetIndexPageServlet и поправил web.xml. Добавил
           <welcome-file-list>
               <welcome-file>index.html</welcome-file>
               <welcome-file>index.jsp</welcome-file>
           </welcome-file-list>

4. Для отображения в консоли сообщений различных уровней надо править в log4j2.xml теги
    <Loggers>
        <Root level="debug">
            <AppenderRef ref="AsyncFile"/>
            <AppenderRef ref="AsyncConsole"/>
        </Root>
    </Loggers>

5. Чтобы в IDEA генерить тестовый класс в папку тест, как в структуре мавена, нужно использовать
   Ctrl+Shift+T in the code editor. It will show you popup with suggestion to create a test.

6. Ссылки на JSP нужно все задавать в виде <form method="POST" action="${pageContext.request.contextPath}/login">
   или <a href="${pageContext.request.contextPath}/signup"> Иначе, при развертке на сервере можно столкнуться с неприятностями

7. Для включения одинакового кода на разные страницы можно ставить ссылку на страницу в виде <jsp:include page="_message_box.jsp"></jsp:include>

8. Post/Redirect/Get (PRG) если при аутентификации возникла ошибка - использовать requestDispatcher().forward()
    Если нет - redirect(). Позволяет избегать повторных запросов к серверу из веб страницы при её обновлении.

9. Из-за этого втсала проблема сообщений. Можно их прикреплять к сессии, но тогда они висят и не удаляются. Удаляем из session scope
    и добавляем в request scope. Только для регистрации и авторизации

10. Т.к. все jsp страницы были доступны по абсолютному пути на сервере, пришлось переносить их в /WEB-INF ,
    который закрыт по умолчанию. Хотя можно было и права доступа назначить через дескриптор развертки
    <security-constraint>
      <web-resource-collection>
        <web-resource-name >precluded methods</web-resource-name>
        <url-pattern >/repositoryFolder/*</url-pattern>
      </web-resource-collection>
      <auth-constraint/>
    </security-constraint>

11. Долго думал, куда поместить проверку авторизации и аутентификации, причем нужно проверять, а не на страницы ли авторизации
    стучится пользователь, чтобы выдать ему сообщения об ошибке. Сначала помещал в doGet сервлетов авторизации - геморр тестировать, потом вывел в два отдельных
    фильтра аутентификации и авторизации, теперь думаю их объединить в один секьюрити фильтр. В итоге объединил в один и замутил там иф элсе логику.

12. Статья с хабра про юнит тесты

Итак, юнит-тест отличается от программы тем, что:
Он на порядок проще, чем тестируемая программа
В нём только набор примеров
В нём нет той логики, что есть в программе (примеры вы придумываете сами)
Юнит-тест не может и не должен покрывать все возможные случаи. Скорее он должен обозначить все важные случаи,
 то есть случаи, которые следует отдельно обговорить.
Юнит-тест должен служить документацией к программе — то есть прочитав юнит-тест, человек должен понять,
 как работает программа. Обычно для этой цели используются названия тест-методов.

 т.е. в юнит тесте не должно быть циклов и условий. Только простые данные на вход, которые тестируют один аспект
 поведения программы.

 Название тест-метода не говорит, что и как должно работать.
 Если вы видите в названии только название того, что тестируется — например, testLeapYear, будьте настороже.
 Вероятно, он не тестирует ничего либо тестирует слишком много. Правильное название тест-метода должно звучать
 примерно так: «в таких-то условиях такой-то метод должен вести себя так-то и так-то».

 В теле тест-метода слишком много assert.
 Такой тест-метод проверяет слишком много аспектов. Если он сломается, по названию метода невозможно
 будет сразу определить, в чём ошибка — вам придётся анализировать код тест-класса.
  Попробуйте разбить тест-метод на несколько методов и дать им говорящие названия.
 Конечно, иногда в тест-методе может быть много assert, например, для того, чтобы проверить,
  что большом HTML присутствуют все необходимые значения. Скорее эту рекомендацию следует пониматькак «делать тесты
   покороче и проверять один возможный путь в одном методе, чтобы было легче локализовать место падения теста.»
 https://habr.com/post/112851/

13. Опять проблемы с подключением CSS, после того, как перенес в папку web-inf. Вынес css в webapp/resources

14. В предыдущей статье « Лучшие практики JSP » я рекомендовал хранить информацию об исключениях в каком-то
 вторичном хранилище и предоставлять пользователю только идентификатор для поиска в хранилище всей трассы исключения.
  Фильтр сервлетов очень полезен в этой ситуации. Вы можете настроить веб-приложение (через web.xmlфайл),
   чтобы автоматически выполнять фильтр сервлета, который регистрирует информацию об исключениях всякий раз,
    когда вызывается исключение JSP. Это позволяет ориентированную на презентацию страницу исключения
    со всем кодом обработки и хранения, помещенным в фильтр перехвата.
    https://www.javaworld.com/article/2075857/java-web-development/jsp-best-practices.html

15. Тестирование сервлетов требует одного и того же кода в каждом тесте. Варианты решения :
а) Утилитный класс, который импортировать и брать из него значения;
б) завести рулу - http://blog.qatools.ru/junit/junit-rules-tutorial;
в) наследование - выбрал наследование.

16. Забудьте об одном тестовом классе для каждого класса, он имеет мало преимуществ.
 Переключитесь на один класс тестирования с точки зрения использования.
 То есть один класс - для схожих кейсов с одинаковым окружением.

17. JUnit
Вместо того, чтобы вручную ловить ожидаемое исключение, используйте ожидаемый атрибут в аннотации @Test от JUnit.

@Test(expected = IOException.class)
public void foo() throws Exception {}

Если тестируем без исключений, а исключение - это провал теста, тогда
Мы объявляем, что метод теста генерирует исключение, а не бросает IOException
Рамка JUnit гарантирует, что этот тест завершится с ошибкой, если какое-либо исключение возникнет
 во время вызова тестируемого метода - нет необходимости писать собственную обработку исключений.
@Test
public void foo() throws Exception {}

18. Полезные инструменты для тестирования
https://tproger.ru/translations/12-tools-for-unit-tests/

19. Подключение к гиту
https://prog.kiev.ua/forum/index.php?topic=1194.0

20. Авторизация - проверка пары логин - пароль. Аутентификация - проверка прав пользователя на доступ к определённой частии приложения.
    Аутентификацию на себя берет security filter. Кроме того, для непубличных частей приложения он проверяет пару логин - пароль.
    Но самой авторизацией занимается отдельный сервлет.

    В безопасности есть 2 важных понятия это  Principal и Role.
    Role (Роль) является набором разрешений (permission) для приложения.
    Чтобы упростить я даю пример, приложение ABC имеет 2 роли  "EMPLOYEE" (сотрудние) и "MANAGER" (Менеджер).
        Роль "EMPLOYEE" позволяет использовать функции продажи, и функции создания информации нового покупателя.
        Роль "MANAGER" позволяет использовать функции менеджмента сотрудников, и смотреть отчет прибыли.
    Principal можно временно понять как "Субъект" после того как вошли в систему, они имеют права сделать что-то в системе. Один "Субъект" может иметь один или много ролей. Это зависит от разрешения пользоваться приложением для разных пользователей.

     Правило работы Security Filter.
     Когда пользователь получает доступ в защищенную страницу (page), Security Filter проверит, если пользователь
     еще не вошел в систему, запрос пользователя будет перенаправлен (redirect) на страницу логина.
     Если пользователь успешно вошел в систему, создается объект  Principal, он приносит информацию пользователя,
     включая все роли.
     Если пользователь успешно вошел в систему до этого, и получил доступ в защищенную страницу (page). Security Filter
      проверит подходят ли роли пользователей для доступа в эту страницу или нет. Если недействительно
      , он отобразит страницу оповещающую запрет доступа (Access Denied) пользователю.