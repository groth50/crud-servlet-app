
Сделано:
1. GetIndexPage
2. SignIn
3. SignUp
4. LogOut
5. GetMainMenu
6. GetAdminMenu
7. SecurityFilter
8. AddUserServlet
9. DeleteUserServlet
10. UpdateUserServlet


MySQL part:
0. Добавить в AddUser выбор роли
1. завязать через DAO AccountService
2. Сделать конфиг DB через XML
3. Все залогировать
4. Все протестировать
5. Сделать 2 версии: напрямую запросами через JDBC и посредством JPA

Заметки:
1.  JPQL и JPA Criteria запросы - https://dou.ua/lenta/articles/jpa-fetch-types/
                                 https://en.wikibooks.org/wiki/Java_Persistence/Criteria#CriteriaQuery

2.  persistence.xml - расположен в каталоге META-INF. описывает блоки хранения.
    Он представляет собой файл описания хранения с использованием Java Persistence API (JPA).
    Он применяется для объявления следующих объектов.

        Управляемые классы хранения.
        Например, к управляемым классам относятся классы, содержащие аннотации @Entity, @Embeddable и @MappedSuperclass.
        Связь между объектом и отношением.
        JPA предлагает несколько способов связывания классов java с таблицами в реляционной базе данных.
        Информация о конфигурации администраторов объектов и классов фабрики администраторов объектов.

    Для корректной работы

pom.xml

<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-entitymanager</artifactId>
    <version>4.3.10.Final</version>
</dependency>

persistence.xml

<persistence xmlns="http://xmlns.jcp.org/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
             http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd"
             version="2.1">

    <persistence-unit name="PERSISTENCE">
        <description> Hibernate JPA Configuration Example</description>
        <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>

        <properties>
            <property name="javax.persistence.jdbc.driver" value="com.mysql.jdbc.Driver" />
            <property name="javax.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/db_example" />
            <property name="javax.persistence.jdbc.user" value="root" />
            <property name="javax.persistence.jdbc.password" value="1234" />
            <property name="hibernate.show_sql" value="true" />
            <property name="hibernate.hbm2ddl.auto" value="validate" />
        </properties>

    </persistence-unit>
</persistence>


3.  ConcurrentHashMap со слабыми ключами
    Я думаю, что Google Guava Collections может дать такую ​​вещь, но могу ли я получить ее из стандартной библиотеки?
    Краткий ответ на этот вопрос - нет. Java SE не реализует эту конкретную комбинацию.
    Вы можете создать экземпляр java.util.concurrent.ConcurrentHashMap с ключами WeakReference и проделать
    дополнительную работу по реализации удаления записей карты для неработающих ссылок,
    но это не даст вам семантику хеширования идентификаторов.

    Вы можете создать экземпляр java.util.IdentityHashMap с ключами WeakReference и выполнить дополнительную работу
    по удалению записей карты для неработающих ссылок, но это не даст вам одновременного поведения.
    Использование java.util.WeakHashMap не даст вам ни параллелизма, ни хеширования идентификаторов.
    Вы можете (теоретически) обернуть ключевой класс чем-то, что отвергает естественные методы equals и hashcode.
    Но это, скорее всего, будет непригодным для использования.
    Я не думаю, что было бы возможно сделать это путем переопределения методов в ConcurrentHashMap или IdentityHashMap.
    Возможно, единственно возможный вариант - изменить классы ключей equals и методы hashcode чтобы они основывались
    на идентичности. Но это не сработает для «встроенных» типов ключей (особенно final ) или для случаев, когда
    вам нужен основанный на значении equals / hashcode в других частях приложения.

    Guava - new MapMaker().weakKeys().makeMap()
    Или Collections.synchronizedMap(weakHashMap)
    https://translate.googleusercontent.com/translate_c?depth=2&hl=ru&rurl=translate.google.com&sl=en&sp=nmt4&tl=ru&u=https://stackoverflow.com/questions/15456742/concurrenthashmap-with-weak-keys-and-identity-hash&xid=17259,15700022,15700124,15700149,15700186,15700190,15700201,15700237,15700242,15700248&usg=ALkJrhi2WEEX57q8F3TvRd6NbADrKZIt_Q

4.  И в чем разница между Session в JPA и в Hibernate?

    Существуют т.н. Container Managed Transactions (CMT), т.е., транзакции, управляемые контейнером.
    Контейнер - это окружение, в котором работает ваше приложение, например - сервер приложений.
    При использовании CMT ваш софт не управляет началом/завершением транзакций,
    вместо этого контейнер сам решает когда начинать транзакции, и когда их завершать.
    Таким образом, в исходном коде у вас нет строк transaction.begin()/transaction.commit().
    При работе с CMT обычно используется EntityManager. Обычно, EntityManager передаётся в ваше
    приложение контейнером с использованием Dependency Injection (DI).
    Существуют Bean Managed Transactions (BMT). Представляют собой то же самое, что и CMT,
    но с одним отличием - вы в коде явно управляете транзакциями, а не доверяете это контейнеру.
    Здесь также применяются EntityManager и DI.
    Существует еще один подход - вы не используете DI, вместо этого в вашем приложении реализован код,
    самостоятельно осуществляющий доступ к источнику данных. В таких приложениях обычно работа
    осуществляется через Session.
    Я описал общий случай, нередко бывают и отличные от него - частные случаи. Например, вам требуется получить
    доступ к специфическим функциям Session в приложении, использующем CMT. Бывают также случаи, когда DI не работает:
    обычно это бывает, когда вам требуется получить доступ к источнику данных из потока,
    созданного не контейнером, а вашим приложением.
    Возможности, доступные из Session и из EntityManager - одинаковы на 99%.
    Решение, что использовать - скорее архитектурное, чем функциональное.
